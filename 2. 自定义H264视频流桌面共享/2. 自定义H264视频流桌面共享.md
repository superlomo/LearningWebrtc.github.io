### 前言

这次我们依旧是实现Windows的桌面共享，但是不同的是，我们将屏蔽掉webrtc自带的抓屏编码，直接使用我们自己的抓屏编码，只使用webrtc进行H264流的传输

### 分析

这次实现主要有以下几个关键点：
1. 上次我们直接使用的是webrtc的编码器，webrtc默认的是VP8，这次我们使用H264的话，需要首先启动webrtc的H264功能，这个该如何实现
2. 如何屏蔽掉webrtc自带的视频采集部分，但又要在SDP中带上我们需要发送视频流的信息
3. 自定义的H264需要在哪里实现，并且能够确保执行线程正确
4. 如何正确地实现webrtc所需要的H264流的格式

### 实现

编码器实现我们主要参考webrtc的h264_encoder的实现，webrtc的h264编码使用的是openH264实现，其实现在 \src\modules\video_coding\codecs\h264\h264_encoder_impl.cc 文件里，主要的编码函数是 int32_t Encode( const VideoFrame& input_frame, const std::vector<VideoFrameType>* frame_types) 函数。其中OpenH264编码器对应的类名为ISVCEncoder

  我们自己的编码采集部分编译集成到webrtc里面来并不顺利，开始我是使用单独的VS工程编译出静态库给peer_conenction使用，但是发现老是链接失败，发现应该是因为使用的编译器不同造成的，我自己的工程使用的是MSVC，而webrtc默认使用的是Clang，虽然修改一些编译选项可能解决，但不能保证以后不再出问题，于是我决定在webrtc的工程里面直接新增一个rtc_library，这个比较简单，直接在GN文件里面添加即可，但是发现编译还是报错，经过反复查看，发现还是Clang编译器的问题，clang在处理WGC相关的一些Windows标准库的时候存在问题，因为这个比较难处理，我转为将Webrtc默认的编译器改为MSVC，这个比较简单，只要在GN生成参数里面加上is_clang=false 即可。此外因为我们的wgc模块需要C++17才能够编译，并且里面还可能抛出异常，于是我们需要单独修改我们的抓屏编码模块加上以下参数：
  '''       cflags = [
        "-EHsc",
        "-std:c++17",
      ] '''

