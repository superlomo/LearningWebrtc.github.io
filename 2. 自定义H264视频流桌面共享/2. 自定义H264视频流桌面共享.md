### 前言

这次我们依旧是实现Windows的桌面共享，但是不同的是，我们将屏蔽掉webrtc自带的抓屏编码，直接使用我们自己的抓屏编码，只使用webrtc进行H264流的传输

### 分析

这次实现主要有以下几个关键点：
1. 上次我们直接使用的是webrtc的编码器，webrtc默认的是VP8，这次我们使用H264的话，需要首先启动webrtc的H264功能，这个该如何实现
2. 如何屏蔽掉webrtc自带的视频采集部分，但又要在SDP中带上我们需要发送视频流的信息
3. 自定义的H264需要在哪里实现，并且能够确保执行线程正确
4. 如何正确地实现webrtc所需要的H264流的格式

### 实现

编码器实现我们主要参考webrtc的h264_encoder的实现，webrtc的h264编码使用的是openH264实现，其实现在 \src\modules\video_coding\codecs\h264\h264_encoder_impl.cc 文件里，主要的编码函数是 int32_t Encode( const VideoFrame& input_frame, const std::vector<VideoFrameType>* frame_types) 函数。其中OpenH264编码器对应的类名为ISVCEncoder

  我们自己的编码采集部分编译集成到webrtc里面来并不顺利，开始我是使用单独的VS工程编译出静态库给peer_conenction client使用，但是发现老是链接失败，发现应该是因为使用的编译器不同造成的，我自己的工程使用的是MSVC，而webrtc默认使用的是Clang，虽然修改一些编译选项可能解决，但不能保证以后不再出问题，于是我决定在webrtc的工程里面直接新增一个rtc_library，这个比较简单，直接在GN文件里面添加即可，但是发现编译还是报错，经过反复查看，发现还是Clang编译器的问题，clang在处理WGC相关的一些Windows标准库的时候存在问题，因为这个比较难处理，我转为将Webrtc默认的编译器改为MSVC，这个比较简单，只要在GN生成参数里面加上is_clang=false 即可。此外因为我们的wgc模块需要C++17才能够编译，并且里面还可能抛出异常，于是我们需要单独修改我们的抓屏编码模块加上以下参数：
  ` cflags = [ "-EHsc", "-std:c++17", ] `其中EHsc大概就是允许抛出异常。但是经过上述修改后发现webrtc自身的编译在修改为MSVC编译器之后无法编译通过，主要原因是ninja在编译的时候带上了 /WX 参数，该参数会将所有的warning当作error，但是我检索了webrtc所有的文件没有找到该项是在哪里设置的，尝试直接修改报错等级为 /W3，但是发现只要不删除 /WX 选项就还是没有作用，后面想到了一个办法就是逐个屏蔽wanring错误，这个修改是放在最顶层的build.gn的config("common_config")里面，内容大致如下：
```
  if (!is_clang && is_win) {
  cflags += [
    "/std:c++17",
    "/wd4267",
    "/wd4715",
    "/wd4312",
  ]
}
```
  本以为这样就皆大欢喜了，但是没想到的是ffmpeg编译的时候又报了一大堆的错误，于是我想算了吧，还是回到clang编译器，这时候有两条路可选，一个是我的采集编码还是单独作为一个工程，导出C的接口，编译为动态库，但是这样感觉单独多了一个DLL很奇怪，于是我决定还是在webrtc的工程里将我们的rtc_library编译通过。
  
  对比我们的和webrtc自带的WGC的实现，主要区别是我们的实现里面使用了winRT，主要是这一部分使用了C++17以及带来了其他的麻烦，这一部分应该可以被省略掉。

