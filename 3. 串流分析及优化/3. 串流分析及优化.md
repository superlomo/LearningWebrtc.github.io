### 前言

这次我们主要是对我们上一节的程序进行bug修复以及优化，主要还是为了学习webrtc。

### 探索

依旧是探索部分，webrtc好像自带了benchmark的代码，可以对串流的各个部分进行耗时统计，帮助我们分析串流效果不佳的问题在哪儿。

不过先不急，主要还是为了熟悉webrtc的视频解码流程。我们先自己实现一个空的视频解码模块，把收到的H264流存到本地文件。这个其实也应该比较简单，我们依旧可以参考webrtc自己的H264解码实现，这一部分在`\src\modules\video_coding\codecs\h264\h264_decoder_impl.cc`文件中。可以看到使用的是ffmpeg进行的H264解码。我们对应地只需要重载几个函数即可，具体实现可以参见我后面的diff文件。主要就是一个`Decode`函数，首先我们只是保存收到的数据到本地文件：
```
 int32_t Decode(const webrtc::EncodedImage& input_image,
                bool missing_frames,
                int64_t render_time_ms) override {
   RTC_LOG(LS_INFO) << "received h264 data size: " << input_image.size()
                    << " frame type: " << (int)input_image._frameType;
   if (!file_wrapper_.is_open()) {
     file_wrapper_ = webrtc::FileWrapper::OpenWriteOnly(
         "received_" +
         std::to_string(webrtc::Random(std::chrono::system_clock()
                                           .now()
                                           .time_since_epoch()
                                           .count())
                            .Rand(99999)) +
         ".h264");
   }
    file_wrapper_.Write(input_image.data(), input_image.size());
   return 0;
}
```
这时候运行程序，发现并没有出现内存泄露的问题，两个peerconnection client进程的内存占用都只是在200多兆，结合之前疯狂的内存泄漏，可以猜测内存占用主要是解码之后的**RGBA**数据。显卡占用稍多，毕竟我们在进行两路4K 60FPS编码，我的显卡是RTX 2070。如果有时间我们可以尝试直接使用Nvidia的硬件解码器，直接解码到**ID3D11Texture2D**，然后直接进行渲染，而完全不走内存，不过这个有时间再弄了。

但是我发现非调试的时候，程序大概率会收不到数据，也就是Decoder的Decode收不到数据，这个应该对应之前的黑屏问题。因为是非调试的时候才会出现，那我们首先要打开webrtc的本地日志文件功能。这个本以为还要自己写，结果发现webrtc自带了一个**FileRotatingLogSink**类，自带旋转的本地日志类，其在**src/rtc_base/log_sinks.h**中。
